import { useState, useEffect } from 'react';
import type { DailyRecord, AnnualMetrics, ClimateSummary, RainMetrics } from '../types/climate.ts';

const DATA_BASE_URL = `${import.meta.env.BASE_URL}data/`;

export interface ClimateDataState {
    dailyData: DailyRecord[] | null;
    metrics: Record<number, AnnualMetrics> | null;
    summary: ClimateSummary | null;
    loading: boolean;
    error: Error | null;
    rainMetrics: Record<number, RainMetrics> | null;
}

/**
 * Fetches all climate data files in parallel.
 *
 * Data sources (generated by data/scripts/generate_web_data.py):
 *  • climate_data.json — daily records (1940–2025)
 *  • metrics.json      — annual ETCCDI metric records
 *  • summary.json      — headline stats
 *  • rain_metrics.json — annual and monthly rain metrics
 *
 * Uses DATA_BASE_URL (= import.meta.env.BASE_URL + "data/") so paths work
 * in both local dev (/) and GitHub Pages (/pindamonhangaba-climate/).
 */
export function useClimateData(): ClimateDataState {
    const [state, setState] = useState<ClimateDataState>({
        dailyData: null,
        metrics: null,
        summary: null,
        rainMetrics: null,
        loading: true,
        error: null,
    });

    useEffect(() => {
        let cancelled = false;

        async function fetchAll() {
            try {
                const [climateRes, metricsRes, summaryRes, rainRes] = await Promise.all([
                    fetch(`${DATA_BASE_URL}climate_data.json`),
                    fetch(`${DATA_BASE_URL}metrics.json`),
                    fetch(`${DATA_BASE_URL}summary.json`),
                    fetch(`${DATA_BASE_URL}rain_metrics.json`),
                ]);

                if (!climateRes.ok)
                    throw new Error(`climate_data.json: HTTP ${climateRes.status}`);
                if (!metricsRes.ok)
                    throw new Error(`metrics.json: HTTP ${metricsRes.status}`);
                if (!summaryRes.ok)
                    throw new Error(`summary.json: HTTP ${summaryRes.status}`);
                if (!rainRes.ok)
                    throw new Error(`rain_metrics.json: HTTP ${rainRes.status}`);

                const [climate, metricsRaw, summaryData, rainRaw] = await Promise.all([
                    climateRes.json() as Promise<DailyRecord[]>,
                    metricsRes.json() as Promise<Record<string, AnnualMetrics>>,
                    summaryRes.json() as Promise<ClimateSummary>,
                    rainRes.json() as Promise<Record<string, RainMetrics>>,
                ]);

                // metrics.json uses string keys — convert to number keys
                const metrics: Record<number, AnnualMetrics> = {};
                for (const [yearStr, val] of Object.entries(metricsRaw)) {
                    const yearNum = parseInt(yearStr, 10);
                    metrics[yearNum] = {
                        ...val,
                        year: yearNum,
                    };
                }

                // Parse rain metrics keys
                const rainMetrics: Record<number, RainMetrics> = {};
                for (const [yearStr, val] of Object.entries(rainRaw)) {
                    const yearNum = parseInt(yearStr, 10);
                    rainMetrics[yearNum] = val;
                }

                if (!cancelled) {
                    setState({
                        dailyData: climate,
                        metrics,
                        summary: summaryData,
                        rainMetrics,
                        loading: false,
                        error: null,
                    });
                }
            } catch (err) {
                if (!cancelled) {
                    setState(prev => ({
                        ...prev,
                        loading: false,
                        error: err instanceof Error ? err : new Error(String(err)),
                    }));
                }
            }
        }

        fetchAll();
        return () => {
            cancelled = true;
        };
    }, []);

    return state;
}
